<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI 체스 게임</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #ececec;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 4px solid black;
    }
    .cell {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
    }
    .white { background-color: #f0d9b5; }
    .black { background-color: #b58863; }
    .highlight { background-color: yellow !important; }
  </style>
</head>
<body>
  <div id="board"></div>
  <script>
    const boardElement = document.getElementById("board");

    const unicodePieces = {
      r: "♜", n: "♞", b: "♝", q: "♛", k: "♚", p: "♟",
      R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔", P: "♙",
    };

    let board = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];

    let currentPlayer = "white";
    let selected = null;
    let enPassantTarget = null;
    let castlingRights = {
      whiteKingMoved: false,
      whiteLeftRookMoved: false,
      whiteRightRookMoved: false,
      blackKingMoved: false,
      blackLeftRookMoved: false,
      blackRightRookMoved: false
    };

    function drawBoard() {
      boardElement.innerHTML = "";
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const cell = document.createElement("div");
          cell.className = "cell " + ((i + j) % 2 === 0 ? "white" : "black");
          cell.dataset.row = i;
          cell.dataset.col = j;
          const piece = board[i][j];
          if (piece) {
            cell.textContent = unicodePieces[piece];
          }
          boardElement.appendChild(cell);
        }
      }
    }

    function isWhite(piece) {
      return piece === piece.toUpperCase();
    }

    function isLegalMove(from, to) {
      const [fr, fc] = from;
      const [tr, tc] = to;
      const piece = board[fr][fc];
      const target = board[tr][tc];

      if (!piece) return false;
      if (target && isWhite(piece) === isWhite(target)) return false;

      const dx = tc - fc;
      const dy = tr - fr;

      const abs = (n) => Math.abs(n);
      const dir = (n) => n > 0 ? 1 : n < 0 ? -1 : 0;

      switch (piece.toLowerCase()) {
        case "p": {
          const dirY = isWhite(piece) ? -1 : 1;
          const startRow = isWhite(piece) ? 6 : 1;

          if (fc === tc && !target) {
            if (tr - fr === dirY) return true;
            if (fr === startRow && tr - fr === dirY * 2 && !board[fr + dirY][fc]) return true;
          } else if (abs(fc - tc) === 1 && tr - fr === dirY) {
            if (target && isWhite(target) !== isWhite(piece)) return true;
            if (!target && enPassantTarget && enPassantTarget[0] === tr && enPassantTarget[1] === tc) return true;
          }
          break;
        }
        case "r": {
          if (fr !== tr && fc !== tc) return false;
          const stepR = dir(tr - fr), stepC = dir(tc - fc);
          for (let i = 1; i < Math.max(abs(tr - fr), abs(tc - fc)); i++) {
            if (board[fr + stepR * i][fc + stepC * i]) return false;
          }
          return true;
        }
        case "n":
          return (abs(dx) === 2 && abs(dy) === 1) || (abs(dx) === 1 && abs(dy) === 2);
        case "b": {
          if (abs(dx) !== abs(dy)) return false;
          const stepR = dir(dy), stepC = dir(dx);
          for (let i = 1; i < abs(dx); i++) {
            if (board[fr + stepR * i][fc + stepC * i]) return false;
          }
          return true;
        }
        case "q":
          return isLegalMove(from, to, "r") || isLegalMove(from, to, "b");
        case "k": {
          if (abs(dx) <= 1 && abs(dy) <= 1) return true;

          if (!target && abs(dx) === 2 && dy === 0) {
            const side = dx > 0 ? "right" : "left";
            if (canCastle(piece, fr, fc, side)) return true;
          }
          return false;
        }
      }
      return false;
    }

    function canCastle(piece, row, col, side) {
      const rights = castlingRights;
      const empty = side === "right"
        ? !board[row][col+1] && !board[row][col+2]
        : !board[row][col-1] && !board[row][col-2] && !board[row][col-3];

      const rookMoved = side === "right"
        ? isWhite(piece) ? rights.whiteRightRookMoved : rights.blackRightRookMoved
        : isWhite(piece) ? rights.whiteLeftRookMoved : rights.blackLeftRookMoved;

      const kingMoved = isWhite(piece)
        ? rights.whiteKingMoved
        : rights.blackKingMoved;

      return empty && !rookMoved && !kingMoved;
    }

    function makeMove(from, to) {
      const [fr, fc] = from;
      const [tr, tc] = to;
      const piece = board[fr][fc];
      const target = board[tr][tc];

      // 캐슬링 처리
      if (piece.toLowerCase() === "k" && abs(tc - fc) === 2) {
        if (tc > fc) { // kingside
          board[tr][5] = board[tr][7];
          board[tr][7] = "";
        } else {
          board[tr][3] = board[tr][0];
          board[tr][0] = "";
        }
      }

      // 앙파상 처리
      if (piece.toLowerCase() === "p" && !target && fc !== tc) {
        board[fr][tc] = "";
      }

      // 프로모션
      if (piece === "P" && tr === 0) {
        const choice = prompt("Promote to (Q/R/B/N):", "Q");
        board[tr][tc] = choice || "Q";
        board[fr][fc] = "";
        return;
      }
      if (piece === "p" && tr === 7) {
        const choice = prompt("Promote to (q/r/b/n):", "q");
        board[tr][tc] = choice || "q";
        board[fr][fc] = "";
        return;
      }

      board[tr][tc] = piece;
      board[fr][fc] = "";

      // 캐슬링 권한 갱신
      if (piece === "K") castlingRights.whiteKingMoved = true;
      if (piece === "k") castlingRights.blackKingMoved = true;
      if (piece === "R" && fr === 7 && fc === 0) castlingRights.whiteLeftRookMoved = true;
      if (piece === "R" && fr === 7 && fc === 7) castlingRights.whiteRightRookMoved = true;
      if (piece === "r" && fr === 0 && fc === 0) castlingRights.blackLeftRookMoved = true;
      if (piece === "r" && fr === 0 && fc === 7) castlingRights.blackRightRookMoved = true;

      // 앙파상 대상 지정
      enPassantTarget = null;
      if (piece.toLowerCase() === "p" && Math.abs(tr - fr) === 2) {
        enPassantTarget = [fr + (tr - fr) / 2, fc];
      }

      currentPlayer = currentPlayer === "white" ? "black" : "white";
    }

    function handleClick(e) {
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      if (isNaN(row) || isNaN(col)) return;

      const piece = board[row][col];

      if (selected) {
        const [sr, sc] = selected;
        const selectedPiece = board[sr][sc];
        if (isWhite(selectedPiece) !== (currentPlayer === "white")) {
          selected = null;
          return;
        }

        if (isLegalMove([sr, sc], [row, col])) {
          makeMove([sr, sc], [row, col]);
        }
        selected = null;
        drawBoard();
      } else if (piece && isWhite(piece) === (currentPlayer === "white")) {
        selected = [row, col];
      }
    }

    boardElement.addEventListener("click", handleClick);
    drawBoard();
  </script>
</body>
</html>
