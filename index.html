<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>체스판 + 기물 + 엄격 이동 규칙 + 차례 관리 + 체크/체크메이트</title>
  <style>
    #board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-template-rows: repeat(8, 70px);
      width: 560px;
      height: 560px;
      border: 3px solid #333;
      margin: 30px auto;
      box-shadow: 0 0 15px rgba(0,0,0,0.3);
      user-select: none;
    }
    .square {
      width: 70px;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 44px;
      cursor: pointer;
      transition: background-color 0.3s;
      border: 1px solid #555;
      box-sizing: border-box;
    }
    .white {
      background-color: #f0d9b5;
    }
    .black {
      background-color: #b58863;
    }
    .square:hover {
      filter: brightness(1.15);
    }
    .selected {
      outline: 3px solid #ff5722;
      outline-offset: -3px;
    }
  </style>
</head>
<body>
  <h1 style="text-align:center; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">
    체스판 + 기물 + 엄격 이동 규칙 + 차례 관리 + 체크/체크메이트
  </h1>

  <div id="turnIndicator" style="text-align:center; font-size:20px; margin-bottom:10px;"></div>
  <div id="board"></div>

  <script>
    const PIECES = {
      'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
      'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
    };

    let boardState = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];

    const boardEl = document.getElementById("board");
    let selected = null;
    let currentTurn = 'white'; // 백이 먼저 둠

    function isUpper(c) { return c === c.toUpperCase(); }
    function isLower(c) { return c === c.toLowerCase(); }

    function inBounds(r, c) {
      return r >= 0 && r < 8 && c >= 0 && c < 8;
    }

    function isOpponent(piece1, piece2) {
      if(!piece1 || !piece2) return false;
      return (isUpper(piece1) && isLower(piece2)) || (isLower(piece1) && isUpper(piece2));
    }

    function getLegalMoves(row, col, board) {
      const piece = board[row][col];
      if (!piece) return [];

      const moves = [];
      const isWhite = isUpper(piece);

      const directions = {
        rook: [[1,0],[-1,0],[0,1],[0,-1]],
        bishop: [[1,1],[1,-1],[-1,1],[-1,-1]],
        knight: [[-2,1],[-2,-1],[-1,2],[-1,-2],[1,2],[1,-2],[2,1],[2,-1]],
        king: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]
      };

      switch(piece.toLowerCase()) {
        case 'p':
          let dir = isWhite ? -1 : 1;
          let startRow = isWhite ? 6 : 1;

          if(inBounds(row+dir,col) && board[row+dir][col] === '') {
            moves.push([row+dir,col]);
            if(row === startRow && board[row+2*dir][col] === '') {
              moves.push([row+2*dir,col]);
            }
          }
          for(let dc of [-1,1]) {
            let nr = row+dir, nc = col+dc;
            if(inBounds(nr,nc) && isOpponent(piece, board[nr][nc])) {
              moves.push([nr,nc]);
            }
          }
          break;

        case 'r':
          for(let [dr, dc] of directions.rook) {
            let nr = row + dr;
            let nc = col + dc;
            while(inBounds(nr,nc)) {
              if(board[nr][nc] === '') {
                moves.push([nr,nc]);
              } else {
                if(isOpponent(piece, board[nr][nc])) moves.push([nr,nc]);
                break;
              }
              nr += dr; nc += dc;
            }
          }
          break;

        case 'n':
          for(let [dr, dc] of directions.knight) {
            let nr = row+dr, nc=col+dc;
            if(inBounds(nr,nc) && (board[nr][nc] === '' || isOpponent(piece, board[nr][nc]))) {
              moves.push([nr,nc]);
            }
          }
          break;

        case 'b':
          for(let [dr, dc] of directions.bishop) {
            let nr = row + dr;
            let nc = col + dc;
            while(inBounds(nr,nc)) {
              if(board[nr][nc] === '') {
                moves.push([nr,nc]);
              } else {
                if(isOpponent(piece, board[nr][nc])) moves.push([nr,nc]);
                break;
              }
              nr += dr; nc += dc;
            }
          }
          break;

        case 'q':
          for(let [dr, dc] of [...directions.rook, ...directions.bishop]) {
            let nr = row + dr;
            let nc = col + dc;
            while(inBounds(nr,nc)) {
              if(board[nr][nc] === '') {
                moves.push([nr,nc]);
              } else {
                if(isOpponent(piece, board[nr][nc])) moves.push([nr,nc]);
                break;
              }
              nr += dr; nc += dc;
            }
          }
          break;

        case 'k':
          for(let [dr, dc] of directions.king) {
            let nr = row+dr;
            let nc = col+dc;
            if(inBounds(nr,nc) && (board[nr][nc] === '' || isOpponent(piece, board[nr][nc]))) {
              moves.push([nr,nc]);
            }
          }
          break;
      }

      return moves;
    }

    // 왕 위치 찾기
    function findKing(board, color) {
      const kingChar = color === 'white' ? 'K' : 'k';
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          if(board[r][c] === kingChar) return [r,c];
        }
      }
      return null;
    }

    // 특정 위치가 상대 공격 범위에 있는지 체크
    function isSquareAttacked(board, r, c, attackerColor) {
      for(let rr=0; rr<8; rr++) {
        for(let cc=0; cc<8; cc++) {
          const piece = board[rr][cc];
          if(!piece) continue;
          if(attackerColor === 'white' ? isUpper(piece) : isLower(piece)) {
            let moves = getLegalMoves(rr, cc, board);
            if(moves.some(([mr, mc]) => mr === r && mc === c)) return true;
          }
        }
      }
      return false;
    }

    // 왕이 체크 상태인지 판정
    function isKingInCheck(board, color) {
      const kingPos = findKing(board, color);
      if(!kingPos) return false;
      const [kr, kc] = kingPos;
      const attackerColor = color === 'white' ? 'black' : 'white';
      return isSquareAttacked(board, kr, kc, attackerColor);
    }

    // 후보 이동 중 체크 검사해서 걸러내기
    function getLegalMovesWithCheck(row, col, board) {
      const possibleMoves = getLegalMoves(row, col, board);
      const piece = board[row][col];
      if(!piece) return [];

      const isWhite = isUpper(piece);
      const color = isWhite ? 'white' : 'black';

      const legalMoves = [];

      for(const [nr, nc] of possibleMoves) {
        const boardCopy = board.map(r => r.slice());
        boardCopy[nr][nc] = boardCopy[row][col];
        boardCopy[row][col] = '';

        if(!isKingInCheck(boardCopy, color)) {
          legalMoves.push([nr,nc]);
        }
      }
      return legalMoves;
    }

    // 체크메이트 판정
    function isCheckmate(board, color) {
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          const piece = board[r][c];
          if(!piece) continue;
          if(color === 'white' ? isUpper(piece) : isLower(piece)) {
            const moves = getLegalMovesWithCheck(r,c,board);
            if(moves.length > 0) return false;
          }
        }
      }
      return true;
    }

    function renderTurn() {
      const el = document.getElementById('turnIndicator');
      el.textContent = currentTurn === 'white' ? "백 차례입니다." : "흑 차례입니다.";
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for(let row=0; row<8; row++) {
        for(let col=0; col<8; col++) {
          const square = document.createElement("div");
          square.classList.add("square");
          if ((row + col) % 2 === 0) square.classList.add("white");
          else square.classList.add("black");

          const piece = boardState[row][col];
          if(piece) square.textContent = PIECES[piece];

          if(selected && selected[0] === row && selected[1] === col) {
            square.classList.add("selected");
          }

          square.dataset.row = row;
          square.dataset.col = col;

          square.addEventListener("click", () => {
            onSquareClick(row, col);
          });

          boardEl.appendChild(square);
        }
      }
      renderTurn();
    }

    function onSquareClick(row, col) {
      const piece = boardState[row][col];

      if(selected === null) {
        if(piece && ((currentTurn === 'white' && isUpper(piece)) || (currentTurn === 'black' && isLower(piece)))) {
          selected = [row, col];
          renderBoard();
        }
      } else {
        if(row === selected[0] && col === selected[1]) {
          selected = null;
          renderBoard();
          return;
        }

        const legalMoves = getLegalMovesWithCheck(selected[0], selected[1], boardState);
        if(legalMoves.some(([r,c]) => r === row && c === col)) {
          boardState[row][col] = boardState[selected[0]][selected[1]];
          boardState[selected[0]][selected[1]] = '';
          selected = null;

          currentTurn = currentTurn === 'white' ? 'black' : 'white';

          renderBoard();

          if(isKingInCheck(boardState, currentTurn)) {
            if(isCheckmate(boardState, currentTurn)) {
              alert((currentTurn === 'white' ? '백' : '흑') + ' 체크메이트! 게임 종료');
            } else {
              alert((currentTurn === 'white' ? '백' : '흑') + ' 체크입니다!');
            }
          }
        } else {
          if(piece && ((currentTurn === 'white' && isUpper(piece)) || (currentTurn === 'black' && isLower(piece)))) {
            selected = [row, col];
            renderBoard();
          } 
        }
      }
    }

    renderBoard();
    <!-- (기존 코드에서 아무것도 삭제하지 않고, 아래 코드만 추가하세요) -->

<script>
  // 폰 프로모션을 처리하는 함수
  function handlePawnPromotion(row, col, piece) {
    const isWhite = isUpper(piece);
    const promotionOptions = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

    let choice = prompt("폰이 도착했습니다! 승격할 기물을 선택하세요 (Q, R, B, N):", "Q");
    if (choice) {
      choice = choice.toUpperCase();
      if (!promotionOptions.includes(isWhite ? choice : choice.toLowerCase())) {
        alert("잘못된 선택입니다. 퀸(Q), 룩(R), 비숍(B), 나이트(N) 중 하나를 선택하세요.");
        return handlePawnPromotion(row, col, piece); // 다시 입력
      }

      boardState[row][col] = isWhite ? choice : choice.toLowerCase();
    }
  }

  // 기존 onSquareClick 함수 내부에서
  // 이동 직후 `프로모션 처리`만 조건에 따라 삽입합니다
  const originalOnSquareClick = onSquareClick;
  onSquareClick = function(row, col) {
    const piece = boardState[row][col];

    if (selected === null) {
      if (piece && ((currentTurn === 'white' && isUpper(piece)) || (currentTurn === 'black' && isLower(piece)))) {
        selected = [row, col];
        renderBoard();
      }
    } else {
      if (row === selected[0] && col === selected[1]) {
        selected = null;
        renderBoard();
        return;
      }

      const legalMoves = getLegalMovesWithCheck(selected[0], selected[1], boardState);
      if (legalMoves.some(([r, c]) => r === row && c === col)) {
        const movingPiece = boardState[selected[0]][selected[1]];
        boardState[row][col] = movingPiece;
        boardState[selected[0]][selected[1]] = '';
        
        //  폰 프로모션 조건 확인
        if ((movingPiece === 'P' && row === 0) || (movingPiece === 'p' && row === 7)) {
          handlePawnPromotion(row, col, movingPiece);
        }

        selected = null;
        currentTurn = currentTurn === 'white' ? 'black' : 'white';
        renderBoard();

        if (isKingInCheck(boardState, currentTurn)) {
          if (isCheckmate(boardState, currentTurn)) {
            alert((currentTurn === 'white' ? '백' : '흑') + ' 체크메이트! 게임 종료');
          } else {
            alert((currentTurn === 'white' ? '백' : '흑') + ' 체크입니다!');
          }
        }
      } else {
        if (piece && ((currentTurn === 'white' && isUpper(piece)) || (currentTurn === 'black' && isLower(piece)))) {
          selected = [row, col];
          renderBoard();
        }
      }
    }
  }
<script>
let castlingRights = {
  white: { kingside: true, queenside: true },
  black: { kingside: true, queenside: true }
};

let enPassantTarget = null; // ex) [3, 4]

// 기존 getLegalMoves 함수 내에 다음 조건을 추가하세요
function getLegalMoves(row, col, board) {
  const piece = board[row][col];
  const isWhite = isUpper(piece);
  const moves = [];

  // (기존 이동 로직)

  // --- 캐슬링 로직 ---
  if (piece.toLowerCase() === 'k') {
    const side = isWhite ? 'white' : 'black';
    const homeRow = isWhite ? 7 : 0;

    if (!isKingInCheck(board, side)) {
      // 킹사이드
      if (castlingRights[side].kingside &&
          board[homeRow][5] === '' &&
          board[homeRow][6] === '' &&
          !isSquareAttacked(homeRow, 5, side) &&
          !isSquareAttacked(homeRow, 6, side) &&
          board[homeRow][7].toLowerCase() === 'r') {
        moves.push([homeRow, 6]);
      }
      // 퀸사이드
      if (castlingRights[side].queenside &&
          board[homeRow][1] === '' &&
          board[homeRow][2] === '' &&
          board[homeRow][3] === '' &&
          !isSquareAttacked(homeRow, 2, side) &&
          !isSquareAttacked(homeRow, 3, side) &&
          board[homeRow][0].toLowerCase() === 'r') {
        moves.push([homeRow, 2]);
      }
    }
  }

  // --- 앙파상 로직 ---
  if (piece.toLowerCase() === 'p') {
    const dir = isWhite ? -1 : 1;
    if (enPassantTarget &&
        enPassantTarget[0] === row + dir &&
        Math.abs(enPassantTarget[1] - col) === 1) {
      moves.push([...enPassantTarget]);
    }
  }

  return moves;
}

// --- 보조 함수: isSquareAttacked ---
function isSquareAttacked(row, col, side) {
  const opponent = side === 'white' ? 'black' : 'white';
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = boardState[r][c];
      if (!piece) continue;
      if ((opponent === 'white' && isUpper(piece)) || (opponent === 'black' && isLower(piece))) {
        const moves = getLegalMoves(r, c, boardState);
        if (moves.some(([mr, mc]) => mr === row && mc === col)) {
          return true;
        }
      }
    }
  }
  return false;
}

// --- onSquareClick에서 이동 처리 이후 상태 업데이트 ---
function handleMove(row, col) {
  const movingPiece = boardState[selected[0]][selected[1]];
  const targetPiece = boardState[row][col];

  // --- 캐슬링 시 룩도 이동 ---
  if (movingPiece.toLowerCase() === 'k' && Math.abs(col - selected[1]) === 2) {
    const rowIdx = selected[0];
    if (col === 6) { // 킹사이드
      boardState[rowIdx][5] = boardState[rowIdx][7];
      boardState[rowIdx][7] = '';
    } else if (col === 2) { // 퀸사이드
      boardState[rowIdx][3] = boardState[rowIdx][0];
      boardState[rowIdx][0] = '';
    }
  }

  // --- 캐슬링 권리 제거 ---
  if (movingPiece === 'K') {
    castlingRights.white.kingside = false;
    castlingRights.white.queenside = false;
  } else if (movingPiece === 'k') {
    castlingRights.black.kingside = false;
    castlingRights.black.queenside = false;
  } else if (movingPiece === 'R') {
    if (selected[0] === 7 && selected[1] === 0) castlingRights.white.queenside = false;
    if (selected[0] === 7 && selected[1] === 7) castlingRights.white.kingside = false;
  } else if (movingPiece === 'r') {
    if (selected[0] === 0 && selected[1] === 0) castlingRights.black.queenside = false;
    if (selected[0] === 0 && selected[1] === 7) castlingRights.black.kingside = false;
  }

  // --- en passant 타겟 설정 ---
  if (movingPiece.toLowerCase() === 'p' && Math.abs(row - selected[0]) === 2) {
    enPassantTarget = [(row + selected[0]) / 2, col];
  } else {
    enPassantTarget = null;
  }

  // --- 앙파상 캡처 처리 ---
  if (movingPiece.toLowerCase() === 'p' &&
      col !== selected[1] &&
      targetPiece === '') {
    const dir = isUpper(movingPiece) ? 1 : -1;
    boardState[row + dir][col] = '';
  }
}
</script>
</body>
</html>
