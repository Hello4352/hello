<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>사람 vs AI 체스</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #eee;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 2px solid #333;
    }
    .cell {
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      user-select: none;
    }
    .white {
      background-color: #f0d9b5;
    }
    .black {
      background-color: #b58863;
    }
    .highlight {
      outline: 3px solid yellow;
    }
  </style>
</head>
<body>
  <div class="board" id="board"></div>

  <script>
    const boardElement = document.getElementById("board");
    let board = [];
    let selected = null;
    let currentTurn = "w";
    let enPassantTarget = null;
    let castlingRights = {
      w: { k: true, q: true },
      b: { k: true, q: true }
    };

    const pieces = {
      r: "♜", n: "♞", b: "♝", q: "♛", k: "♚", p: "♟",
      R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔", P: "♙"
    };

    const initialSetup = [
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];

    function drawBoard() {
      boardElement.innerHTML = "";
      for (let i = 0; i < 8; i++) {
        board[i] = [];
        for (let j = 0; j < 8; j++) {
          const cell = document.createElement("div");
          cell.className = "cell " + ((i + j) % 2 ? "black" : "white");
          cell.dataset.row = i;
          cell.dataset.col = j;
          const piece = initialSetup[i][j];
          board[i][j] = piece;
          cell.textContent = pieces[piece] || "";
          cell.addEventListener("click", handleClick);
          boardElement.appendChild(cell);
        }
      }
    }

    function isWhite(piece) {
      return piece >= "A" && piece <= "Z";
    }

    function isBlack(piece) {
      return piece >= "a" && piece <= "z";
    }

    function isCurrentTurnPiece(piece) {
      return piece && ((currentTurn === "w" && isWhite(piece)) || (currentTurn === "b" && isBlack(piece)));
    }

    function handleClick(e) {
      const row = +e.currentTarget.dataset.row;
      const col = +e.currentTarget.dataset.col;
      const piece = board[row][col];

      if (selected) {
        const [fromRow, fromCol] = selected;
        const selectedPiece = board[fromRow][fromCol];
        if (fromRow === row && fromCol === col) {
          selected = null;
          drawBoard();
          return;
        }
        if (isValidMove(fromRow, fromCol, row, col)) {
          makeMove(fromRow, fromCol, row, col);
          selected = null;
          drawBoard();
          return;
        } else {
          selected = null;
          drawBoard();
          return;
        }
      }

      if (isCurrentTurnPiece(piece)) {
        selected = [row, col];
        drawBoard();
        const cellIndex = row * 8 + col;
        boardElement.children[cellIndex].classList.add("highlight");
      }
    }

    function makeMove(fromRow, fromCol, toRow, toCol) {
      const movingPiece = board[fromRow][fromCol];
      const targetPiece = board[toRow][toCol];

      // 캐슬링
      if (movingPiece.toUpperCase() === "K" && Math.abs(toCol - fromCol) === 2) {
        const rookCol = toCol > fromCol ? 7 : 0;
        const newRookCol = toCol > fromCol ? toCol - 1 : toCol + 1;
        board[toRow][toCol] = movingPiece;
        board[fromRow][fromCol] = "";
        board[toRow][newRookCol] = board[toRow][rookCol];
        board[toRow][rookCol] = "";
        castlingRights[currentTurn].k = false;
        castlingRights[currentTurn].q = false;
        currentTurn = currentTurn === "w" ? "b" : "w";
        return;
      }

      // 앙파상
      if (movingPiece.toUpperCase() === "P" && toCol !== fromCol && !targetPiece) {
        board[toRow][toCol] = movingPiece;
        board[fromRow][fromCol] = "";
        board[fromRow][toCol] = "";
      } else {
        board[toRow][toCol] = movingPiece;
        board[fromRow][fromCol] = "";
      }

      // 앙파상 타겟 설정
      if (movingPiece.toUpperCase() === "P" && Math.abs(toRow - fromRow) === 2) {
        enPassantTarget = [ (fromRow + toRow) / 2, fromCol ];
      } else {
        enPassantTarget = null;
      }

      // 캐슬링 권한 제거
      if (movingPiece.toUpperCase() === "K") {
        castlingRights[currentTurn].k = false;
        castlingRights[currentTurn].q = false;
      }
      if (movingPiece.toUpperCase() === "R") {
        if (fromCol === 0) castlingRights[currentTurn].q = false;
        if (fromCol === 7) castlingRights[currentTurn].k = false;
      }

      currentTurn = currentTurn === "w" ? "b" : "w";
    }

    function isValidMove(fr, fc, tr, tc) {
      const piece = board[fr][fc];
      const target = board[tr][tc];
      const dr = tr - fr;
      const dc = tc - fc;

      const isWhitePiece = isWhite(piece);
      const direction = isWhitePiece ? -1 : 1;
      const enemy = isWhitePiece ? isBlack : isWhite;

      if (piece.toUpperCase() === "P") {
        // 일반 이동
        if (dc === 0 && !target) {
          if (dr === direction) return true;
          if ((isWhitePiece && fr === 6 || !isWhitePiece && fr === 1) && dr === 2 * direction && !board[fr + direction][fc]) return true;
        }
        // 잡기
        if (Math.abs(dc) === 1 && dr === direction && enemy(target)) return true;
        // 앙파상
        if (enPassantTarget && tr === enPassantTarget[0] && tc === enPassantTarget[1]) {
          return true;
        }
      }

      if (piece.toUpperCase() === "R") {
        if (fc === tc || fr === tr) return pathClear(fr, fc, tr, tc);
      }

      if (piece.toUpperCase() === "N") {
        return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);
      }

      if (piece.toUpperCase() === "B") {
        return Math.abs(dr) === Math.abs(dc) && pathClear(fr, fc, tr, tc);
      }

      if (piece.toUpperCase() === "Q") {
        if (fc === tc || fr === tr || Math.abs(dr) === Math.abs(dc)) return pathClear(fr, fc, tr, tc);
      }

      if (piece.toUpperCase() === "K") {
        if (Math.abs(dr) <= 1 && Math.abs(dc) <= 1) return true;
        // 캐슬링
        if (!target && dr === 0 && Math.abs(dc) === 2) {
          const side = dc === 2 ? "k" : "q";
          if (!castlingRights[currentTurn][side]) return false;
          const rookCol = dc === 2 ? 7 : 0;
          if (board[fr][rookCol].toUpperCase() !== "R") return false;
          return pathClear(fr, fc, fr, rookCol);
        }
      }

      return false;
    }

    function pathClear(fr, fc, tr, tc) {
      const dr = Math.sign(tr - fr);
      const dc = Math.sign(tc - fc);
      let r = fr + dr, c = fc + dc;
      while (r !== tr || c !== tc) {
        if (board[r][c]) return false;
        r += dr;
        c += dc;
      }
      return true;
    }

    drawBoard();
  </script>
</body>
</html>
